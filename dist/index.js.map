{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isPlainObject = require( '@stdlib/assert-is-plain-object' );\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar isndarrayLike = require( '@stdlib/assert-is-ndarray-like' );\nvar isOrder = require( '@stdlib/ndarray-base-assert-is-order' );\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar ctors = require( '@stdlib/ndarray-base-buffer-ctors' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar getShape = require( '@stdlib/ndarray-shape' );\nvar getDType = require( '@stdlib/ndarray-dtype' );\nvar getOrder = require( '@stdlib/ndarray-order' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar nextCartesianIndex = require( '@stdlib/ndarray-base-next-cartesian-index' ).assign;\nvar gcopy = require( '@stdlib/blas-base-gcopy' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Returns a shallow copy of an ndarray containing only those elements which fail a test implemented by a predicate function.\n*\n* @param {ndarray} x - input ndarray\n* @param {Options} [options] - function options\n* @param {string} [options.dtype] - output array data type\n* @param {boolean} [options.order] - index iteration order\n* @param {Callback} predicate - predicate function\n* @param {*} [thisArg] - predicate execution context\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} callback argument must be a function\n* @throws {TypeError} options argument must be an object\n* @returns {ndarray} output ndarray\n*\n* @example\n* var isOdd = require( '@stdlib/assert-is-odd' ).isPrimitive;\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n*\n* var buffer = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var shape = [ 2, 3 ];\n* var strides = [ 6, 1 ];\n* var offset = 1;\n*\n* var x = ndarray( 'float64', buffer, shape, strides, offset, 'row-major' );\n* // returns <ndarray>\n*\n* var y = reject( x, isOdd );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( y );\n* // returns [ 2.0, 4.0, 8.0, 10.0 ]\n*/\nfunction reject( x, options, predicate, thisArg ) {\n\tvar hasOpts;\n\tvar ndims;\n\tvar cache;\n\tvar clbk;\n\tvar opts;\n\tvar ctor;\n\tvar ctx;\n\tvar ord;\n\tvar dim;\n\tvar idx;\n\tvar buf;\n\tvar dt;\n\tvar sh;\n\tvar N;\n\tvar y;\n\tvar v;\n\tvar i;\n\tif ( !isndarrayLike( x ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an ndarray-like object. Value: `%s`.', x ) );\n\t}\n\tif ( arguments.length < 3 ) {\n\t\tclbk = options;\n\t} else if ( arguments.length === 3 ) {\n\t\tif ( isFunction( options ) ) {\n\t\t\tclbk = options;\n\t\t\tctx = predicate;\n\t\t} else {\n\t\t\thasOpts = true;\n\t\t\topts = options;\n\t\t\tclbk = predicate;\n\t\t}\n\t} else {\n\t\thasOpts = true;\n\t\topts = options;\n\t\tclbk = predicate;\n\t\tctx = thisArg;\n\t}\n\tif ( !isFunction( clbk ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Callback argument must be a function. Value: `%s`.', clbk ) );\n\t}\n\tif ( hasOpts ) {\n\t\tif ( !isPlainObject( opts ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', opts ) );\n\t\t}\n\t\tif ( hasOwnProp( opts, 'dtype' ) ) {\n\t\t\tdt = opts.dtype;\n\t\t} else {\n\t\t\tdt = getDType( x );\n\t\t}\n\t\tif ( hasOwnProp( opts, 'order' ) ) {\n\t\t\tif ( !isOrder( opts.order ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be a recognized order. Option: `%s`.', 'order', opts.order ) );\n\t\t\t}\n\t\t\tord = opts.order;\n\t\t}\n\t} else {\n\t\tdt = getDType( x );\n\t}\n\t// Resolve an output array buffer constructor:\n\tctor = ctors( dt );\n\tif ( ctor === null ) {\n\t\t// The only way we should get here is if the user provided an unsupported data type, as `getDType` should error if the input array has an unrecognized/unsupported data type...\n\t\tthrow new TypeError( format( 'invalid option. `%s` option must be a recognized data type. Option: `%s`.', 'dtype', opts.dtype ) );\n\t}\n\t// Resolve the iteration order:\n\tif ( ord === void 0 ) {\n\t\tord = getOrder( x );\n\t}\n\t// Resolve the input array shape:\n\tsh = getShape( x );\n\n\t// Compute the number of array elements:\n\tN = numel( sh );\n\n\t// Retrieve the number of dimensions:\n\tndims = sh.length;\n\n\t// Resolve the dimension in which indices should iterate fastest:\n\tif ( ord === 'row-major' ) {\n\t\tdim = ndims - 1;\n\t} else { // ord === 'column-major'\n\t\tdim = 0;\n\t}\n\t// Initialize an index array workspace:\n\tidx = zeros( ndims );\n\n\t// Initialize a value cache for those elements which pass a predicate function (note: unfortunately, we use an associative array here, as no other good options. If we use a \"generic\" array, we are limited to 2^32-1 elements. If we allocate, say, a Float64Array buffer for storing indices, we risk materializing lazily-materialized input ndarray values again (e.g., lazy accessor ndarray), which could be expensive. If we allocate a workspace buffer of equal size to the input ndarray to store materialized values, we'd then need to perform another copy in order to shrink the buffer, as, otherwise, could be holding on to significantly more memory than needed for the returned ndarray. There are likely other options, but all involve complexity, so the simplest option is used here.):\n\tcache = {\n\t\t'length': 0\n\t};\n\n\t// Filter elements according to a predicate function...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( i > 0 ) {\n\t\t\tidx = nextCartesianIndex( sh, ord, idx, dim, idx );\n\t\t}\n\t\tv = x.get.apply( x, idx );\n\t\tif ( !clbk.call( ctx, v, idx.slice(), x ) ) {\n\t\t\tcache[ cache.length ] = v;\n\t\t\tcache.length += 1;\n\t\t}\n\t}\n\t// Retrieve the number of cached elements:\n\tN = cache.length;\n\n\t// Allocate an output array buffer:\n\tbuf = new ctor( N );\n\n\t// Copy cached elements to the output array buffer:\n\tgcopy( N, cache, 1, buf, 1 );\n\n\t// Create an output ndarray:\n\ty = new x.constructor( dt, buf, [ N ], [ 1 ], 0, ord );\n\n\treturn y;\n}\n\n\n// EXPORTS //\n\nmodule.exports = reject;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return a shallow copy of an ndarray containing only those elements which fail a test implemented by a predicate function.\n*\n* @module @stdlib/ndarray-reject\n*\n* @example\n* var isOdd = require( '@stdlib/assert-is-odd' ).isPrimitive;\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n* var reject = require( '@stdlib/ndarray-reject' );\n*\n* var buffer = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var shape = [ 2, 3 ];\n* var strides = [ 6, 1 ];\n* var offset = 1;\n*\n* var x = ndarray( 'float64', buffer, shape, strides, offset, 'row-major' );\n* // returns <ndarray>\n*\n* var y = reject( x, isOdd );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( y );\n* // returns [ 2.0, 4.0, 8.0, 10.0 ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAgB,QAAS,gCAAiC,EAC1DC,EAAa,QAAS,4BAA6B,EACnDC,EAAgB,QAAS,gCAAiC,EAC1DC,EAAU,QAAS,sCAAuC,EAC1DC,EAAa,QAAS,iCAAkC,EACxDC,EAAQ,QAAS,mCAAoC,EACrDC,EAAQ,QAAS,0BAA2B,EAC5CC,EAAW,QAAS,uBAAwB,EAC5CC,EAAW,QAAS,uBAAwB,EAC5CC,EAAW,QAAS,uBAAwB,EAC5CC,EAAQ,QAAS,4BAA6B,EAC9CC,EAAqB,QAAS,2CAA4C,EAAE,OAC5EC,EAAQ,QAAS,yBAA0B,EAC3CC,EAAS,QAAS,uBAAwB,EAuC9C,SAASC,EAAQC,EAAGC,EAASC,EAAWC,EAAU,CACjD,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACJ,GAAK,CAACjC,EAAea,CAAE,EACtB,MAAM,IAAI,UAAWF,EAAQ,gFAAiFE,CAAE,CAAE,EAmBnH,GAjBK,UAAU,OAAS,EACvBO,EAAON,EACI,UAAU,SAAW,EAC3Bf,EAAYe,CAAQ,GACxBM,EAAON,EACPS,EAAMR,IAENE,EAAU,GACVI,EAAOP,EACPM,EAAOL,IAGRE,EAAU,GACVI,EAAOP,EACPM,EAAOL,EACPQ,EAAMP,GAEF,CAACjB,EAAYqB,CAAK,EACtB,MAAM,IAAI,UAAWT,EAAQ,uEAAwES,CAAK,CAAE,EAE7G,GAAKH,EAAU,CACd,GAAK,CAACnB,EAAeuB,CAAK,EACzB,MAAM,IAAI,UAAWV,EAAQ,qEAAsEU,CAAK,CAAE,EAO3G,GALKnB,EAAYmB,EAAM,OAAQ,EAC9BO,EAAKP,EAAK,MAEVO,EAAKtB,EAAUO,CAAE,EAEbX,EAAYmB,EAAM,OAAQ,EAAI,CAClC,GAAK,CAACpB,EAASoB,EAAK,KAAM,EACzB,MAAM,IAAI,UAAWV,EAAQ,wEAAyE,QAASU,EAAK,KAAM,CAAE,EAE7HG,EAAMH,EAAK,KACZ,CACD,MACCO,EAAKtB,EAAUO,CAAE,EAIlB,GADAS,EAAOnB,EAAOyB,CAAG,EACZN,IAAS,KAEb,MAAM,IAAI,UAAWX,EAAQ,4EAA6E,QAASU,EAAK,KAAM,CAAE,EA8BjI,IA3BKG,IAAQ,SACZA,EAAMjB,EAAUM,CAAE,GAGnBgB,EAAKxB,EAAUQ,CAAE,EAGjBiB,EAAItB,EAAOqB,CAAG,EAGdX,EAAQW,EAAG,OAGNL,IAAQ,YACZC,EAAMP,EAAQ,EAEdO,EAAM,EAGPC,EAAMtB,EAAOc,CAAM,EAGnBC,EAAQ,CACP,OAAU,CACX,EAGMc,EAAI,EAAGA,EAAIH,EAAGG,IACdA,EAAI,IACRP,EAAMjB,EAAoBoB,EAAIL,EAAKE,EAAKD,EAAKC,CAAI,GAElDM,EAAInB,EAAE,IAAI,MAAOA,EAAGa,CAAI,EAClBN,EAAK,KAAMG,EAAKS,EAAGN,EAAI,MAAM,EAAGb,CAAE,IACvCM,EAAOA,EAAM,MAAO,EAAIa,EACxBb,EAAM,QAAU,GAIlB,OAAAW,EAAIX,EAAM,OAGVQ,EAAM,IAAIL,EAAMQ,CAAE,EAGlBpB,EAAOoB,EAAGX,EAAO,EAAGQ,EAAK,CAAE,EAG3BI,EAAI,IAAIlB,EAAE,YAAae,EAAID,EAAK,CAAEG,CAAE,EAAG,CAAE,CAAE,EAAG,EAAGN,CAAI,EAE9CO,CACR,CAKAlC,EAAO,QAAUe,IClJjB,IAAIsB,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isPlainObject", "isFunction", "isndarrayLike", "isOrder", "hasOwnProp", "ctors", "zeros", "getShape", "getDType", "getOrder", "numel", "nextCartesianIndex", "gcopy", "format", "reject", "x", "options", "predicate", "thisArg", "hasOpts", "ndims", "cache", "clbk", "opts", "ctor", "ctx", "ord", "dim", "idx", "buf", "dt", "sh", "N", "y", "v", "i", "main"]
}
